<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Transcript Extractor</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', 'Arial', sans-serif;
        }
        .youtube-gradient {
            background: linear-gradient(135deg, #FF0000 0%, #CC0000 100%);
        }
        .btn-youtube {
            background-color: #FF0000;
            transition: all 0.3s ease;
        }
        .btn-youtube:hover {
            background-color: #CC0000;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 0, 0, 0.4);
        }
        .btn-youtube:active {
            transform: translateY(0);
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #FF0000;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .toast {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .transcript-line {
            margin-bottom: 1rem;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        const ENGLISH_VARIANTS = [
            'en', 'a.en', 'en-US', 'en-GB', 'en-CA', 'en-AU', 'en-IN', 'en-ZA', 'en-NZ', 'en-IE'
        ];

        const CORS_PROXIES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/'
        ];

        function App() {
            const [url, setUrl] = useState('');
            const [transcript, setTranscript] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [toast, setToast] = useState(null);
            const [videoId, setVideoId] = useState(null);

            const showToast = (message, type = 'success') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };

            const extractVideoId = (url) => {
                const patterns = [
                    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                    /youtube\.com\/watch\?.*v=([^&\n?#]+)/
                ];

                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1]) {
                        return match[1];
                    }
                }
                return null;
            };

            const fetchWithProxy = async (url, proxyIndex = 0) => {
                if (proxyIndex >= CORS_PROXIES.length) {
                    throw new Error('All CORS proxies failed');
                }

                try {
                    const proxy = CORS_PROXIES[proxyIndex];
                    const response = await fetch(proxy + encodeURIComponent(url));
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    return await response.text();
                } catch (err) {
                    console.warn(`Proxy ${proxyIndex + 1} failed:`, err);
                    return fetchWithProxy(url, proxyIndex + 1);
                }
            };

            const extractCaptionData = (html, videoId) => {
                try {
                    let captionTracks = null;

                    // Try to find ytInitialPlayerResponse with greedy matching
                    const playerResponseMatch = html.match(/var ytInitialPlayerResponse = ({[\s\S]*?});/);
                    if (playerResponseMatch) {
                        try {
                            const playerResponse = JSON.parse(playerResponseMatch[1]);
                            captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
                            if (captionTracks && captionTracks.length > 0) {
                                return captionTracks;
                            }
                        } catch (e) {
                            console.warn('Failed to parse ytInitialPlayerResponse:', e);
                        }
                    }

                    // Alternative: Find captions in the HTML using different patterns
                    // Look for the captions object more flexibly
                    const captionsPatterns = [
                        /"captions":\s*{\s*"playerCaptionsTracklistRenderer":\s*{\s*"captionTracks":\s*(\[[\s\S]*?\])/,
                        /"playerCaptionsTracklistRenderer":\s*{\s*"captionTracks":\s*(\[[\s\S]*?\])/,
                        /"captionTracks":\s*(\[[\s\S]*?\]),\s*"translationLanguages"/
                    ];

                    for (const pattern of captionsPatterns) {
                        const match = html.match(pattern);
                        if (match) {
                            try {
                                const tracks = JSON.parse(match[1]);
                                if (Array.isArray(tracks) && tracks.length > 0) {
                                    return tracks;
                                }
                            } catch (e) {
                                console.warn('Failed to parse captions pattern:', e);
                            }
                        }
                    }

                    // Try parsing as complete JSON object with captions
                    try {
                        const jsonMatch = html.match(/ytInitialPlayerResponse\s*=\s*({[\s\S]*?});[\s\S]*?</);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[1]);
                            captionTracks = parsed?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
                            if (captionTracks && captionTracks.length > 0) {
                                return captionTracks;
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to parse complete JSON:', e);
                    }

                    // Last resort: Extract just the captionTracks array
                    const tracksMatch = html.match(/"captionTracks":\s*(\[[\s\S]*?\])/);
                    if (tracksMatch) {
                        try {
                            // Handle potential nested closing brackets
                            let tracksJson = tracksMatch[1];
                            let braceCount = 0;
                            let inString = false;
                            let escaped = false;
                            let endIndex = 0;

                            for (let i = 0; i < tracksJson.length; i++) {
                                const char = tracksJson[i];
                                
                                if (escaped) {
                                    escaped = false;
                                    continue;
                                }

                                if (char === '\\') {
                                    escaped = true;
                                    continue;
                                }

                                if (char === '"' && !escaped) {
                                    inString = !inString;
                                    continue;
                                }

                                if (!inString) {
                                    if (char === '{') braceCount++;
                                    if (char === '}') braceCount--;
                                    if (char === ']' && braceCount === 0) {
                                        endIndex = i + 1;
                                        break;
                                    }
                                }
                            }

                            if (endIndex > 0) {
                                tracksJson = tracksJson.substring(0, endIndex);
                            }

                            const tracks = JSON.parse(tracksJson);
                            if (Array.isArray(tracks) && tracks.length > 0) {
                                return tracks;
                            }
                        } catch (e) {
                            console.warn('Failed to parse tracks:', e);
                        }
                    }

                    throw new Error('No captions available for this video');
                } catch (err) {
                    throw new Error(`Failed to parse caption data: ${err.message}`);
                }
            };

            const findEnglishCaptionUrl = (captionTracks) => {
                if (!Array.isArray(captionTracks)) {
                    return null;
                }

                for (const langCode of ENGLISH_VARIANTS) {
                    for (const track of captionTracks) {
                        const trackLangCode = track.languageCode || '';
                        const trackVssId = track.vssId || '';
                        
                        if (
                            trackLangCode === langCode || 
                            trackVssId === `.${langCode}` ||
                            trackVssId === `a.${langCode}` ||
                            trackVssId === langCode ||
                            trackLangCode.startsWith(langCode)
                        ) {
                            if (track.baseUrl) {
                                return { url: track.baseUrl, langCode: trackLangCode };
                            }
                        }
                    }
                }

                // If no specific English variant found, try any English caption
                for (const track of captionTracks) {
                    const trackLangCode = track.languageCode || '';
                    if (trackLangCode.toLowerCase().includes('en') && track.baseUrl) {
                        return { url: track.baseUrl, langCode: trackLangCode };
                    }
                }

                return null;
            };

            const parseCaptionXml = (xml) => {
                if (!xml || typeof xml !== 'string') {
                    throw new Error('Invalid caption data');
                }

                // First try to parse as XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xml, 'text/xml');
                
                // Check for XML parsing errors
                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                    throw new Error('Could not parse caption XML');
                }

                const textElements = xmlDoc.getElementsByTagName('text');
                
                if (textElements.length === 0) {
                    // Try alternative parsing - look for text content directly
                    const match = xml.match(/<text[^>]*>([^<]*)<\/text>/g);
                    if (!match || match.length === 0) {
                        throw new Error('No captions found in XML');
                    }
                }

                const lines = [];
                for (let i = 0; i < textElements.length; i++) {
                    let text = textElements[i].textContent || '';
                    // Decode HTML entities
                    text = text.replace(/&amp;/g, '&')
                               .replace(/&lt;/g, '<')
                               .replace(/&gt;/g, '>')
                               .replace(/&quot;/g, '"')
                               .replace(/&#39;/g, "'")
                               .replace(/&nbsp;/g, ' ')
                               .replace(/&apos;/g, "'")
                               .replace(/<[^>]*>/g, '')
                               .replace(/\n/g, ' ')
                               .trim();
                    
                    if (text && text.length > 0) {
                        lines.push(text);
                    }
                }

                if (lines.length === 0) {
                    throw new Error('No captions extracted from XML');
                }
                
                return lines.join(' ');
            };

            const handleExtract = async () => {
                setError(null);
                setTranscript(null);
                setVideoId(null);

                const vId = extractVideoId(url);
                if (!vId) {
                    setError('Invalid YouTube URL. Please enter a valid URL like: https://www.youtube.com/watch?v=VIDEO_ID or https://youtu.be/VIDEO_ID');
                    return;
                }

                setVideoId(vId);
                setLoading(true);

                try {
                    // Fetch YouTube page HTML
                    const youtubeUrl = `https://www.youtube.com/watch?v=${vId}`;
                    let html;
                    try {
                        html = await fetchWithProxy(youtubeUrl);
                    } catch (proxyErr) {
                        console.error('Proxy error:', proxyErr);
                        setLoading(false);
                        setError(`Network error: Could not fetch YouTube page. ${proxyErr.message}. The CORS proxies may be temporarily unavailable.`);
                        return;
                    }

                    if (!html || html.length < 1000) {
                        setLoading(false);
                        setError('Received incomplete data from YouTube. The CORS proxy may have issues. Please try again.');
                        return;
                    }

                    // Extract caption tracks
                    let captionTracks;
                    try {
                        captionTracks = extractCaptionData(html, vId);
                    } catch (parseErr) {
                        console.error('Parse error:', parseErr);
                        setLoading(false);
                        setError(`Failed to parse YouTube data: ${parseErr.message}. The video might not have captions or the page format changed.`);
                        return;
                    }

                    if (!captionTracks || captionTracks.length === 0) {
                        setLoading(false);
                        setError('This video does not appear to have captions available. Please verify the video has subtitles/captions enabled.');
                        return;
                    }

                    // Find English caption URL
                    const captionInfo = findEnglishCaptionUrl(captionTracks);
                    
                    if (!captionInfo) {
                        const availableLangs = captionTracks.map(t => t.languageCode || t.vssId || 'unknown').filter(l => l).join(', ');
                        setLoading(false);
                        setError(`No English captions found for this video. Available languages: ${availableLangs || 'none'}. Tried all 10 English variants.`);
                        return;
                    }

                    // Fetch caption XML
                    let captionXml;
                    try {
                        captionXml = await fetchWithProxy(captionInfo.url);
                    } catch (captionErr) {
                        console.error('Caption fetch error:', captionErr);
                        setLoading(false);
                        setError(`Failed to fetch transcript data: ${captionErr.message}`);
                        return;
                    }

                    // Parse caption XML
                    let transcriptText;
                    try {
                        transcriptText = parseCaptionXml(captionXml);
                    } catch (parseXmlErr) {
                        console.error('XML parse error:', parseXmlErr);
                        setLoading(false);
                        setError(`Failed to parse transcript XML: ${parseXmlErr.message}`);
                        return;
                    }

                    if (!transcriptText || transcriptText.trim().length === 0) {
                        setLoading(false);
                        setError('Transcript extraction succeeded but resulted in empty text');
                        return;
                    }

                    setTranscript(transcriptText);
                    showToast(`Successfully extracted transcript (${captionInfo.langCode})!`, 'success');
                } catch (err) {
                    console.error('Unexpected extraction error:', err);
                    setLoading(false);
                    setError(`An unexpected error occurred: ${err.message}`);
                }
            };

            const handleCopy = async () => {
                if (!transcript) return;

                try {
                    await navigator.clipboard.writeText(transcript);
                    showToast('Transcript copied to clipboard!', 'success');
                } catch (err) {
                    showToast('Failed to copy to clipboard', 'error');
                }
            };

            const handleDownload = () => {
                if (!transcript || !videoId) return;

                const metadata = `YouTube Video: https://www.youtube.com/watch?v=${videoId}\nVideo ID: ${videoId}\n\n--- TRANSCRIPT ---\n\n`;
                const content = metadata + transcript;
                
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `youtube-transcript-${videoId}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('Transcript downloaded!', 'success');
            };

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Header */}
                    <header className="youtube-gradient shadow-lg">
                        <div className="max-w-6xl mx-auto px-4 py-6">
                            <div className="flex items-center space-x-3">
                                <svg className="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                                </svg>
                                <h1 className="text-3xl font-bold text-white">YouTube Transcript Extractor</h1>
                            </div>
                            <p className="text-white text-sm mt-2 opacity-90">Extract captions from any YouTube video instantly</p>
                        </div>
                    </header>

                    {/* Toast Notification */}
                    {toast && (
                        <div className={`fixed top-20 right-4 z-50 toast px-6 py-3 rounded-lg shadow-lg ${
                            toast.type === 'success' ? 'bg-green-500' : 'bg-red-500'
                        } text-white font-medium`}>
                            {toast.message}
                        </div>
                    )}

                    {/* Main Content */}
                    <main className="max-w-6xl mx-auto px-4 py-8">
                        {/* Input Section */}
                        <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                            <label className="block text-gray-700 font-semibold mb-2">
                                YouTube Video URL
                            </label>
                            <input
                                type="text"
                                value={url}
                                onChange={(e) => setUrl(e.target.value)}
                                onKeyPress={(e) => e.key === 'Enter' && handleExtract()}
                                placeholder="https://www.youtube.com/watch?v=dQw4w9WgXcQ or https://youtu.be/dQw4w9WgXcQ"
                                className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-red-500 focus:outline-none transition-colors"
                                disabled={loading}
                            />
                            <button
                                onClick={handleExtract}
                                disabled={loading || !url}
                                className="btn-youtube w-full mt-4 px-6 py-3 text-white font-semibold rounded-lg disabled:opacity-50 disabled:cursor-not-allowed shadow-md"
                            >
                                {loading ? 'Extracting Transcript...' : 'Extract Transcript'}
                            </button>
                        </div>

                        {/* Loading State */}
                        {loading && (
                            <div className="bg-white rounded-lg shadow-md p-12 flex flex-col items-center justify-center">
                                <div className="spinner mb-4"></div>
                                <p className="text-gray-600 font-medium">Fetching transcript from YouTube...</p>
                                <p className="text-gray-500 text-sm mt-2">Trying all available English caption variants</p>
                            </div>
                        )}

                        {/* Error State */}
                        {error && !loading && (
                            <div className="bg-red-50 border-l-4 border-red-500 rounded-lg p-6 mb-6">
                                <div className="flex items-start">
                                    <svg className="w-6 h-6 text-red-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd"/>
                                    </svg>
                                    <div className="ml-3">
                                        <h3 className="text-red-800 font-semibold">Error</h3>
                                        <p className="text-red-700 mt-1">{error}</p>
                                        <div className="mt-3 text-sm text-red-600">
                                            <p className="font-medium">Troubleshooting tips:</p>
                                            <ul className="list-disc list-inside mt-1 space-y-1">
                                                <li>Ensure the video is publicly accessible</li>
                                                <li>Check if the video has captions/subtitles enabled</li>
                                                <li>Try a different video to verify functionality</li>
                                                <li>Some videos may have region restrictions</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Transcript Display */}
                        {transcript && !loading && (
                            <div className="bg-white rounded-lg shadow-md overflow-hidden">
                                <div className="bg-gray-800 px-6 py-4 flex items-center justify-between">
                                    <h2 className="text-white font-semibold text-lg">Transcript</h2>
                                    <div className="flex space-x-3">
                                        <button
                                            onClick={handleCopy}
                                            className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors font-medium text-sm flex items-center space-x-2"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                            </svg>
                                            <span>Copy</span>
                                        </button>
                                        <button
                                            onClick={handleDownload}
                                            className="btn-youtube px-4 py-2 text-white rounded-lg font-medium text-sm flex items-center space-x-2"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                            </svg>
                                            <span>Download as .txt</span>
                                        </button>
                                    </div>
                                </div>
                                <div className="p-6 max-h-[600px] overflow-y-auto">
                                    <div className="transcript-line text-gray-800 text-base leading-relaxed whitespace-pre-wrap">
                                        {transcript}
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Instructions */}
                        {!transcript && !loading && !error && (
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h3 className="text-xl font-semibold text-gray-800 mb-4">How to Use</h3>
                                <ol className="space-y-3 text-gray-700">
                                    <li className="flex items-start">
                                        <span className="font-bold text-red-500 mr-3">1.</span>
                                        <span>Paste a YouTube video URL in the input field above</span>
                                    </li>
                                    <li className="flex items-start">
                                        <span className="font-bold text-red-500 mr-3">2.</span>
                                        <span>Click "Extract Transcript" or press Enter</span>
                                    </li>
                                    <li className="flex items-start">
                                        <span className="font-bold text-red-500 mr-3">3.</span>
                                        <span>Wait for the transcript to be extracted (supports all English variants)</span>
                                    </li>
                                    <li className="flex items-start">
                                        <span className="font-bold text-red-500 mr-3">4.</span>
                                        <span>Use "Copy" to copy to clipboard or "Download as .txt" to save the file</span>
                                    </li>
                                </ol>
                                <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                    <p className="text-sm text-gray-600">
                                        <strong>Note:</strong> This tool extracts publicly available captions from YouTube videos. 
                                        The video must have captions/subtitles enabled. We support all English language variants including 
                                        en, en-US, en-GB, en-CA, en-AU, en-IN, en-ZA, en-NZ, en-IE, and auto-generated English captions.
                                    </p>
                                </div>
                            </div>
                        )}
                    </main>

                    {/* Footer */}
                    <footer className="bg-gray-800 mt-12 py-6">
                        <div className="max-w-6xl mx-auto px-4 text-center text-gray-400 text-sm">
                            <p>YouTube Transcript Extractor - Extract captions from any YouTube video</p>
                            <p className="mt-2">No embedded videos, no tracking - just pure transcript extraction</p>
                        </div>
                    </footer>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
