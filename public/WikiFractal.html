<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WikiFractal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=Inter:wght@400;500&display=swap');

        :root {
            --bg: #050508;
            --card-bg: #121217;
            --border: #27272a;
            --accent: #3b82f6;
            --text: #e2e8f0;
            --line-color: #3f3f46;
            --line-active: #3b82f6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body { 
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: none;
        }

        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            position: relative;
            touch-action: none;
            background-image: radial-gradient(circle at 1px 1px, #1c1c1f 1px, transparent 0);
            background-size: 40px 40px;
        }
        #viewport.panning { cursor: grabbing; }

        #world {
            position: absolute;
            display: flex;
            align-items: center;
            padding: 0;
            transform-origin: 0 0;
            will-change: transform;
            backface-visibility: hidden;
            perspective: 1000px;
            transform-style: preserve-3d;
        }

        /* --- TREE LAYOUT ENGINE --- */
        
        .node-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 60px; /* Space for connectors */
            position: relative;
            margin-bottom: 20px;
            contain: layout style;
        }

        .card {
            width: 400px;
            height: 550px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10; /* Above connectors */
            box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        
        .card:hover {
            border-color: #52525b;
            box-shadow: 0 20px 40px -5px rgba(0,0,0,0.7);
            z-index: 20;
        }
        
        .card.path-active {
            border-color: var(--line-active);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }

        .children-stack {
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
            /* SVG Connector Container */
            min-width: 10px; 
        }

        /* --- ORGANIC CONNECTORS (SVG) --- */
        .connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 100%;
            overflow: visible;
            pointer-events: none;
            z-index: 0; /* Behind cards */
            color: var(--line-color);
            transition: color 0.3s ease;
        }
        
        .children-stack.path-active .connector-svg {
            color: var(--line-active);
        }

        /* Fade in new paths */
        .connector-path {
            opacity: 0;
            animation: fadeInPath 0.6s ease-out forwards;
        }
        @keyframes fadeInPath { from { opacity: 0; } to { opacity: 1; } }


        /* --- UI ELEMENTS --- */
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; border-bottom: 1px solid var(--border);
            background: rgba(255,255,255,0.02); border-radius: 12px 12px 0 0;
        }

        .card-title {
            font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 1.1rem; color: #fff;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 300px;
        }

        .card-body {
            flex: 1; overflow-y: auto; padding: 24px;
            font-size: 0.95rem; line-height: 1.6; color: #d1d5db;
            scroll-behavior: smooth;
        }
        .card-body::-webkit-scrollbar { width: 6px; }
        .card-body::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }
        .card-body::-webkit-scrollbar-track { background: transparent; }

        .wiki-text h2 { font-family: 'Space Grotesk'; color: #fff; margin: 1.5rem 0 0.5rem; font-size: 1.2rem; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .wiki-text p { margin-bottom: 1rem; }
        .wiki-text a { color: var(--accent); text-decoration: none; border-bottom: 1px solid rgba(59,130,246,0.3); transition: all 0.2s; }
        .wiki-text a:hover { border-bottom-color: var(--accent); background: rgba(59,130,246,0.1); }
        .wiki-text ul { list-style: disc; margin-left: 1.5rem; margin-bottom: 1rem; color: #a1a1aa; }
        .wiki-text blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: #94a3b8; font-style: italic; margin: 1rem 0; }
        .wiki-text img { max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0; }
        .wiki-text .thumb { display: none; }

        /* --- UI OVERLAYS --- */
        .search-bar {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 100; width: 420px; background: rgba(18,18,23,0.8); backdrop-filter: blur(12px);
            border: 1px solid var(--border); border-radius: 12px;
            padding: 12px 16px; display: flex; align-items: center; gap: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: border-color 0.2s;
        }
        .search-bar:focus-within { border-color: var(--accent); }
        .search-input { background: transparent; border: none; outline: none; color: white; width: 100%; font-size: 1rem; font-family: 'Inter', sans-serif; }
        
        .suggestions {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            width: 420px; background: #121217; border: 1px solid var(--border);
            border-radius: 12px; overflow: hidden; display: none; z-index: 99;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        .suggestions.active { display: block; }
        .s-item { padding: 12px 16px; border-bottom: 1px solid #27272a; cursor: pointer; color: #a1a1aa; display: flex; justify-content: space-between; transition: background 0.1s; }
        .s-item:hover { background: #27272a; color: white; }

        .controls { 
            position: fixed; bottom: 30px; right: 30px; 
            display: flex; flex-direction: column; gap: 10px; z-index: 90; 
        }
        .btn { 
            width: 44px; height: 44px; background: rgba(18,18,23,0.9); backdrop-filter: blur(12px);
            border: 1px solid var(--border); border-radius: 8px; color: #a1a1aa; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-size: 1.2rem;
        }
        .btn:hover { border-color: var(--accent); color: white; background: #27272a; }
        .zoom-level {
            background: rgba(18,18,23,0.9); border: 1px solid var(--border); 
            border-radius: 8px; padding: 4px 0; color: #fff;
            font-family: 'Space Grotesk', sans-serif; font-size: 0.8rem;
            text-align: center; width: 44px; margin-bottom: 4px;
        }

        .spinner { border: 2px solid #333; border-top-color: var(--accent); border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- MOBILE --- */
        @media (max-width: 768px) {
            .node-wrapper { gap: 30px; margin-bottom: 10px; }
            .card { width: 320px; height: 450px; }
            .search-bar { width: calc(100% - 40px); top: 20px; }
            .suggestions { width: calc(100% - 40px); top: 75px; }
            .controls { bottom: 20px; right: 20px; }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "dompurify": "https://esm.sh/dompurify@^3.3.1",
    "uuid": "https://esm.sh/uuid@^13.0.0",
    "gsap": "https://esm.sh/gsap@^3.14.2"
  }
}
</script>
</head>
<body>

    <div class="search-bar">
        <i class="ri-search-line text-gray-500"></i>
        <input type="text" id="searchInput" class="search-input" placeholder="Search Wikipedia..." autocomplete="off">
        <div id="loader" class="spinner" style="opacity: 0;"></div>
    </div>
    <div id="suggestions" class="suggestions"></div>

    <div class="controls">
        <button class="btn" onclick="zoomIn()" title="Zoom In"><i class="ri-add-line"></i></button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="btn" onclick="zoomOut()" title="Zoom Out"><i class="ri-subtract-line"></i></button>
        <button class="btn" onclick="resetView()" title="Reset View"><i class="ri-focus-3-line"></i></button>
    </div>

    <div id="viewport">
        <div id="world"></div>
    </div>

    <script>
        // --- State ---
        const state = {
            isMobile: window.innerWidth <= 768,
            scale: 1,
            x: 0, y: 0,
            isDragging: false,
            startX: 0, startY: 0,
            velocityX: 0, velocityY: 0,
            lastDragTime: 0,
            lastDragX: 0, lastDragY: 0,
            touchStartDist: 0,
            touchStartScale: 1,
            currentController: null,
            nodeCount: 0
        };

        const APIS = {
            wikipedia: 'https://en.wikipedia.org/w/api.php?origin=*',
            wiktionary: 'https://en.wiktionary.org/w/api.php?origin=*'
        };

        const dom = {
            viewport: document.getElementById('viewport'),
            world: document.getElementById('world'),
            input: document.getElementById('searchInput'),
            suggestions: document.getElementById('suggestions'),
            loader: document.getElementById('loader'),
            zoomLevel: document.getElementById('zoomLevel')
        };

        function checkDevice() {
            state.isMobile = window.innerWidth <= 768;
            // Redraw all connectors on resize
            document.querySelectorAll('.children-stack').forEach(updateStackConnectors);
        }
        window.addEventListener('resize', checkDevice);
        
        function updateTransform() {
            dom.world.style.transform = `translate3d(${state.x}px, ${state.y}px, 0) scale(${state.scale})`;
            if (dom.zoomLevel) dom.zoomLevel.textContent = `${Math.round(state.scale * 100)}%`;
        }

        // --- Viewport Interactions ---

        function handleStart(clientX, clientY) {
            state.isDragging = true;
            state.startX = clientX - state.x;
            state.startY = clientY - state.y;
            state.lastDragTime = Date.now();
            state.lastDragX = state.x;
            state.lastDragY = state.y;
            state.velocityX = 0; state.velocityY = 0;
            gsap.killTweensOf(state);
            dom.viewport.classList.add('panning');
        }

        function handleMove(clientX, clientY) {
            if (!state.isDragging) return;
            const now = Date.now();
            const currentX = clientX - state.startX;
            const currentY = clientY - state.startY;
            
            // Momentum Calc
            const dt = now - state.lastDragTime;
            if (dt > 0) {
                state.velocityX = (currentX - state.lastDragX) / dt;
                state.velocityY = (currentY - state.lastDragY) / dt;
            }
            state.lastDragTime = now;
            state.lastDragX = currentX;
            state.lastDragY = currentY;

            state.x = currentX;
            state.y = currentY;
            requestAnimationFrame(updateTransform);
        }

        function handleEnd() {
            if (!state.isDragging) return;
            state.isDragging = false;
            dom.viewport.classList.remove('panning');
            
            // Apply Momentum
            if (Math.hypot(state.velocityX, state.velocityY) > 0.1) {
                gsap.to(state, {
                    x: state.x + state.velocityX * 300,
                    y: state.y + state.velocityY * 300,
                    duration: 0.8,
                    ease: "power2.out",
                    onUpdate: updateTransform
                });
            }
        }

        dom.viewport.addEventListener('mousedown', (e) => {
            if (e.target.closest('.card-body') || e.target.closest('input') || e.target.closest('button')) return;
            handleStart(e.clientX, e.clientY);
        });
        window.addEventListener('mousemove', (e) => {
            e.preventDefault(); handleMove(e.clientX, e.clientY);
        });
        window.addEventListener('mouseup', handleEnd);

        dom.viewport.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                zoom(e.deltaY * -0.001, e.clientX, e.clientY);
            } else {
                if (e.target.closest('.card-body')) return;
                e.preventDefault();
                gsap.killTweensOf(state);
                state.x -= e.deltaX;
                state.y -= e.deltaY;
                updateTransform();
            }
        }, { passive: false });

        dom.viewport.addEventListener('touchstart', (e) => {
            if (e.target.closest('.card-body') || e.target.closest('input') || e.target.closest('button')) return;
            if(e.touches.length === 2) {
                 e.preventDefault();
                 state.isDragging = false;
                 const dx = e.touches[0].clientX - e.touches[1].clientX;
                 const dy = e.touches[0].clientY - e.touches[1].clientY;
                 state.touchStartDist = Math.hypot(dx, dy);
                 state.touchStartScale = state.scale;
            } else {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        dom.viewport.addEventListener('touchmove', (e) => {
            if(e.touches.length === 2) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);
                const scaleFactor = dist / state.touchStartDist;
                const newScale = Math.min(Math.max(0.1, state.touchStartScale * scaleFactor), 3);
                
                const rect = dom.viewport.getBoundingClientRect();
                const mx = rect.width/2; 
                const my = rect.height/2;
                state.scale = newScale;
                updateTransform();
            } else {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
        dom.viewport.addEventListener('touchend', handleEnd);


        // --- Core Functions ---
        function zoom(delta, centerX, centerY) {
            const currentScale = state.scale;
            const newScale = Math.min(Math.max(0.1, currentScale + delta), 2.5);
            
            const rect = dom.viewport.getBoundingClientRect();
            const mx = centerX ?? (rect.width/2);
            const my = centerY ?? (rect.height/2);
            
            const worldX = (mx - state.x) / currentScale;
            const worldY = (my - state.y) / currentScale;
            
            state.x = mx - worldX * newScale;
            state.y = my - worldY * newScale;
            state.scale = newScale;
            
            if (!centerX) {
                gsap.to(state, { scale: newScale, x: state.x, y: state.y, duration: 0.3, onUpdate: updateTransform });
            } else {
                updateTransform();
            }
        }

        async function fetchSuggestions(query) {
            if (query.length < 2) return [];
            if (state.currentController) state.currentController.abort();
            state.currentController = new AbortController();
            
            try {
                // Fetch BOTH APIs in parallel
                const [wikiRes, dictRes] = await Promise.all([
                    fetch(`${APIS.wikipedia}&action=opensearch&search=${encodeURIComponent(query)}&limit=5&format=json`, { signal: state.currentController.signal }),
                    fetch(`${APIS.wiktionary}&action=opensearch&search=${encodeURIComponent(query)}&limit=5&format=json`, { signal: state.currentController.signal })
                ]);

                const wikiData = await wikiRes.json();
                const dictData = await dictRes.json();
                
                const results = [];
                // Process Wiki
                if (wikiData[1]) {
                    wikiData[1].forEach((t, i) => results.push({ title: t, desc: wikiData[2][i], source: 'wikipedia' }));
                }
                // Process Dict
                if (dictData[1]) {
                    dictData[1].forEach((t, i) => results.push({ title: t, desc: dictData[2][i], source: 'wiktionary' }));
                }
                
                return results;
            } catch (error) { return []; }
        }

        async function fetchPage(title, source) {
            // Select correct API based on source parameter
            const apiBase = APIS[source] || APIS.wikipedia; 
            try {
                const res = await fetch(`${apiBase}&action=parse&page=${encodeURIComponent(title)}&format=json&prop=text|displaytitle&redirects=1&disableeditsection=1`);
                const data = await res.json();
                if (data.error) throw new Error(data.error.info);
                return { title: data.parse.displaytitle || title, html: data.parse.text['*'] };
            } catch (error) { return { error: error.message || 'Error loading page' }; }
        }

        // --- Organic Connector Logic ---

        function updateStackConnectors(stack) {
            if (!stack) return;
            
            const isMobile = window.innerWidth <= 768;
            const gap = isMobile ? 30 : 60; // Matches CSS .node-wrapper gap
            const cardHeight = isMobile ? 450 : 550;
            const cardHalf = cardHeight / 2;
            
            // Get or create SVG container
            let svg = stack.querySelector('.connector-svg');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'connector-svg');
                stack.prepend(svg);
            }
            
            svg.innerHTML = '';
            
            const children = Array.from(stack.children).filter(c => c.classList.contains('node-wrapper'));
            if (children.length === 0) return;

            // Geometry: 
            // Parent Exit: x = -gap, y = cardHalf (relative to stack top-left)
            // Child Entry: x = 0, y = child.offsetTop + cardHalf
            
            const startX = -gap;
            const startY = cardHalf; 
            const startThick = 8; // Trunk thickness
            const endThick = 2;   // Tip thickness
            
            children.forEach(child => {
                const childY = child.offsetTop;
                const endX = 0; 
                const endY = childY + cardHalf;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connector-path');
                path.setAttribute('fill', 'currentColor');
                
                // Organic Curve Shape (Filled Path for tapering)
                // We create a closed loop shape that represents the "muscle" or "branch"
                const dist = Math.abs(endX - startX);
                const cp1x = startX + (dist * 0.6); // Control points extend horizontally
                const cp1y = startY;
                const cp2x = endX - (dist * 0.6);
                const cp2y = endY;
                
                // Top curve (Parent Top -> Child Top)
                // Bottom curve (Child Bottom -> Parent Bottom)
                const d = [
                    `M ${startX} ${startY - startThick/2}`,
                    `C ${cp1x} ${cp1y - startThick/2}, ${cp2x} ${cp2y - endThick/2}, ${endX} ${endY - endThick/2}`,
                    `L ${endX} ${endY + endThick/2}`,
                    `C ${cp2x} ${cp2y + endThick/2}, ${cp1x} ${cp1y + startThick/2}, ${startX} ${startY + startThick/2}`,
                    `Z`
                ].join(' ');
                
                path.setAttribute('d', d);
                svg.appendChild(path);
            });
        }

        // --- Tree Node Logic ---

        function highlightPath(element, active) {
            let current = element;
            while(current && current.id !== 'world') {
                if(current.classList.contains('node-wrapper')) {
                    active ? current.classList.add('path-active') : current.classList.remove('path-active');
                }
                if(current.classList.contains('children-stack')) {
                    active ? current.classList.add('path-active') : current.classList.remove('path-active');
                }
                current = current.parentElement;
            }
        }

        // Modified createNode to accept and handle 'source'
        function createNode(title, parentStack = null, source = 'wikipedia') {
            state.nodeCount++;
            const wrapper = document.createElement('div');
            wrapper.className = 'node-wrapper';

            const card = document.createElement('div');
            card.className = 'card';
            // Store source for logic, but don't style off it
            card.setAttribute('data-source', source);

            card.innerHTML = `
                <div class="card-header">
                    <div class="card-title">${title}</div>
                    <i class="ri-close-line" style="cursor:pointer; opacity:0.6;" onclick="removeNode(this)"></i>
                </div>
                <div class="card-body">
                    <div style="display:flex; justify-content:center; align-items:center; height:100px; gap:10px; color:#555;">
                        <div class="spinner"></div> Loading...
                    </div>
                </div>
            `;
            
            card.addEventListener('mouseenter', () => highlightPath(wrapper, true));
            card.addEventListener('mouseleave', () => highlightPath(wrapper, false));

            wrapper.appendChild(card);
            
            gsap.from(card, { opacity:0, x:-20, duration:0.4, clearProps:"all" });

            if (!parentStack) {
                dom.world.innerHTML = '';
                dom.world.appendChild(wrapper);
                setTimeout(resetView, 100);
            } else {
                parentStack.appendChild(wrapper);
                // Update lines for this stack
                updateStackConnectors(parentStack);
            }

            fetchPage(title, source).then(data => {
                const body = card.querySelector('.card-body');
                if(data.error) {
                    body.innerHTML = `<div style="text-align:center; padding:20px; color:#ef4444;">${data.error}</div>`;
                    return;
                }
                
                const clean = DOMPurify.sanitize(data.html, {
                    FORBID_TAGS: ['style','script','iframe','form','meta','link','style'],
                    ALLOWED_TAGS: ['p','br','strong','b','em','i','u','s','a','h2','h3','ul','ol','li','blockquote','pre','code','span','div','img'],
                    ALLOWED_ATTR: ['href','src','alt','title','class','id']
                });
                
                card.querySelector('.card-title').innerHTML = data.title;
                body.innerHTML = clean;
                body.classList.add('wiki-text');

                body.querySelectorAll('a').forEach(link => {
                    const href = link.getAttribute('href');
                    if(href && href.startsWith('/wiki/')) {
                        const target = href.replace('/wiki/', '').split('#')[0];
                        if(target.includes(':')) { 
                            link.style.opacity = 0.5; link.removeAttribute('href'); return; 
                        }
                        link.onclick = (e) => {
                            e.preventDefault();
                            // Pass the 'source' (wiki or wiktionary) to child
                            spawnChild(wrapper, target, source);
                        };
                    } else {
                        link.target = "_blank";
                        link.innerHTML += ' <i class="ri-external-link-line" style="font-size:0.8em"></i>';
                    }
                });
            });
        }

        function spawnChild(parentWrapper, title, source) {
            let stack = parentWrapper.querySelector('.children-stack');
            if(!stack) {
                stack = document.createElement('div');
                stack.className = 'children-stack';
                parentWrapper.appendChild(stack);
            }
            
            // Check for existing node (including source check to avoid duplicates)
            const existing = Array.from(stack.children)
                .filter(el => el.classList.contains('node-wrapper'))
                .find(wrapper => {
                    const card = wrapper.querySelector('.card');
                    const titleEl = card.querySelector('.card-title');
                    return titleEl.textContent === title && card.getAttribute('data-source') === source;
                });

            if(existing) {
                const card = existing.querySelector('.card');
                gsap.to(card, { borderColor: '#f59e0b', duration: 0.2, yoyo: true, repeat: 3 });
                return;
            }

            createNode(title, stack, source);
            // Connectors updated inside createNode
        }

        function removeNode(icon) {
            const wrapper = icon.closest('.node-wrapper');
            const stack = wrapper.parentElement;
            
            gsap.to(wrapper, { 
                opacity: 0, 
                height: 0, 
                marginBottom: 0,
                duration: 0.3, 
                onUpdate: () => {
                   // Keep lines connected during collapse
                   if(stack && stack.classList.contains('children-stack')) updateStackConnectors(stack);
                },
                onComplete: () => {
                    wrapper.remove();
                    
                    if(stack && stack.classList.contains('children-stack')) {
                        const remainingNodes = Array.from(stack.children).filter(c => c.classList.contains('node-wrapper'));
                        if(remainingNodes.length === 0) {
                            stack.remove();
                        } else {
                            updateStackConnectors(stack);
                        }
                    }
                } 
            });
        }

        // --- Search & UI ---
        let debounce;
        dom.input.addEventListener('input', (e) => {
            if (debounce) clearTimeout(debounce);
            const val = e.target.value;
            if(val.length < 2) { 
                dom.suggestions.classList.remove('active'); 
                dom.loader.style.opacity = 0; 
                return; 
            }
            
            dom.loader.style.opacity = 1;
            debounce = setTimeout(async () => {
                const results = await fetchSuggestions(val);
                dom.loader.style.opacity = 0;
                renderSuggestions(results);
            }, 300);
        });

        function renderSuggestions(list) {
            dom.suggestions.innerHTML = '';
            if(list.length === 0) { dom.suggestions.classList.remove('active'); return; }
            
            list.forEach(item => {
                const div = document.createElement('div');
                div.className = 's-item';
                // Using exact original structure, but showing source in description if useful,
                // or just standard description.
                div.innerHTML = `
                    <div style="font-weight:500; color:#e2e8f0">${item.title}</div>
                    <div style="font-size:0.85em; opacity:0.6; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:200px;">${item.desc || (item.source === 'wiktionary' ? 'Definition' : 'Article')}</div>
                `;
                div.onclick = () => {
                    // Pass the item's source
                    createNode(item.title, null, item.source);
                    dom.suggestions.classList.remove('active');
                    dom.input.value = '';
                };
                dom.suggestions.appendChild(div);
            });
            dom.suggestions.classList.add('active');
        }

        // Controls
        function zoomIn() { zoom(0.3); }
        function zoomOut() { zoom(-0.3); }
        function resetView() {
            const root = dom.world.querySelector('.node-wrapper .card');
            if(!root) return;
            const cardW = state.isMobile ? 320 : 400;
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            state.x = (screenW / 2) - (cardW / 2);
            state.y = (screenH / 2) - 275;
            state.scale = 1;
            gsap.to(state, { x: state.x, y: state.y, scale: 1, duration: 0.8, ease: "power2.inOut", onUpdate: updateTransform });
        }

        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
                e.preventDefault();
                const step = 100 / state.scale;
                if(e.key === 'ArrowLeft') state.x += step;
                if(e.key === 'ArrowRight') state.x -= step;
                if(e.key === 'ArrowUp') state.y += step;
                if(e.key === 'ArrowDown') state.y -= step;
                updateTransform();
            }
        });

        checkDevice();
        createNode("Fractal");

    </script>
</body>
</html>
