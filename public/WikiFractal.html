<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WikiFractal</title>
    
    <!-- External Styles -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=Inter:wght@400;500&display=swap');
        
        body {
            background-color: #050508;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent native scrolling on body */
            touch-action: none; /* Prevent browser gestures */
        }

        /* Custom Scrollbar for Cards */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { 
            background: #3f3f46; 
            border-radius: 3px; 
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #52525b; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }

        /* Typography overrides for Wiki Content */
        .wiki-content h2 { font-family: 'Space Grotesk'; color: #fff; margin: 1.2rem 0 0.5rem; font-size: 1.3rem; font-weight: 600; }
        .wiki-content h3 { font-family: 'Space Grotesk'; color: #e2e8f0; margin: 1rem 0 0.4rem; font-size: 1.1rem; font-weight: 600; }
        .wiki-content p { margin-bottom: 0.8rem; line-height: 1.6; }
        .wiki-content a { color: #3b82f6; text-decoration: none; border-bottom: 1px solid rgba(59,130,246,0.3); }
        .wiki-content ul, .wiki-content ol { margin-left: 1.5rem; margin-bottom: 1rem; list-style: disc; }
        .wiki-content blockquote { border-left: 3px solid #3b82f6; padding-left: 1rem; margin: 1rem 0; color: #cbd5e1; background: rgba(59,130,246,0.05); padding: 0.8rem; border-radius: 0 8px 8px 0; }
        .wiki-content .thumb { display: none; } /* Hide heavy images/captions by default for cleaner UI */
        .wiki-content table { display: block; overflow-x: auto; margin: 1rem 0; border-collapse: collapse; }
        .wiki-content th, .wiki-content td { border: 1px solid #333; padding: 8px; }
    </style>

    <!-- Dependencies (React, Babel, GSAP, etc.) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "dompurify": "https://esm.sh/dompurify@^3.3.1",
    "uuid": "https://esm.sh/uuid@^13.0.0",
    "gsap": "https://esm.sh/gsap@^3.14.2"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- React Hooks & Utils ---
        const { useState, useEffect, useRef, useCallback } = React;

        // --- API Services ---
        const API_BASE = 'https://en.wikipedia.org/w/api.php?origin=*';

        const fetchSuggestions = async (query, signal) => {
            if (query.length < 2) return [];
            const response = await fetch(
                `${API_BASE}&action=opensearch&search=${encodeURIComponent(query)}&limit=5&format=json`,
                { signal }
            );
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            const titles = data[1];
            const descriptions = data[2];
            return titles.map((title, index) => ({
                title,
                description: descriptions[index] || '',
            }));
        };

        const fetchWikiPage = async (title) => {
            const response = await fetch(
                `${API_BASE}&action=parse&page=${encodeURIComponent(title)}&format=json&prop=text|displaytitle&redirects=1&disableeditsection=1`
            );
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            if (data.error) throw new Error(data.error.info || 'Wikipedia API Error');
            if (!data.parse || !data.parse.text || !data.parse.text['*']) throw new Error('Invalid response format');
            return {
                title: data.parse.displaytitle || title,
                html: data.parse.text['*'],
            };
        };

        // --- Components ---

        const WikiCard = ({ node, isMobile, onClose, onLinkClick }) => {
            const contentRef = useRef(null);

            useEffect(() => {
                const container = contentRef.current;
                if (!container) return;
                const handleLinkClick = (e) => {
                    const target = e.target.closest('a');
                    if (!target) return;
                    const href = target.getAttribute('href');
                    if (href && href.startsWith('/wiki/')) {
                        e.preventDefault();
                        const rawTitle = href.replace('/wiki/', '').split('#')[0];
                        const title = decodeURIComponent(rawTitle);
                        if (title.includes(':')) return;
                        onLinkClick(title, node.id);
                    } else {
                        target.setAttribute('target', '_blank');
                        target.setAttribute('rel', 'noopener noreferrer');
                    }
                };
                container.addEventListener('click', handleLinkClick);
                return () => container.removeEventListener('click', handleLinkClick);
            }, [node.id, onLinkClick, node.content]);

            const sanitizedHTML = node.content
                ? DOMPurify.sanitize(node.content, {
                    FORBID_TAGS: ['style', 'script', 'iframe', 'form', 'meta', 'link'],
                    ALLOWED_TAGS: [
                        'p', 'br', 'strong', 'b', 'em', 'i', 'u', 's', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                        'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'span', 'div', 'table', 'tr', 'td', 'th',
                        'thead', 'tbody', 'caption', 'img', 'sup', 'sub'
                    ],
                    ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'id', 'colspan', 'rowspan', 'align'],
                })
                : '';

            return (
                <div
                    className={`
                        flex flex-col flex-shrink-0 bg-[#121217] border border-[#27272a] rounded-2xl shadow-2xl relative
                        transition-colors duration-200 hover:border-zinc-600
                        ${isMobile ? 'w-[340px] h-[500px]' : 'w-[450px] h-[600px]'}
                    `}
                    style={{ boxShadow: '0 25px 50px -12px rgba(0,0,0,0.5)', backfaceVisibility: 'hidden' }}
                >
                    <div className="flex justify-between items-center px-5 py-4 border-b border-[#27272a] bg-white/5 rounded-t-2xl">
                        <h3 className="font-['Space_Grotesk'] font-semibold text-white truncate max-w-[85%]" dangerouslySetInnerHTML={{ __html: node.title }} />
                        {node.parentId && (
                            <button onClick={(e) => { e.stopPropagation(); onClose(node.id); }} className="text-zinc-500 hover:text-red-400 transition-colors p-1" aria-label="Close card">
                                <i className="ri-close-line text-xl"></i>
                            </button>
                        )}
                    </div>
                    <div ref={contentRef} className="flex-1 overflow-y-auto custom-scrollbar p-6 bg-[#121217]">
                        {node.loading ? (
                            <div className="flex flex-col items-center justify-center h-full text-zinc-500 gap-3">
                                <div className="w-5 h-5 border-2 border-zinc-700 border-t-blue-500 rounded-full animate-spin"></div>
                                <span className="text-sm">Fetching knowledge...</span>
                            </div>
                        ) : node.error ? (
                            <div className="flex flex-col items-center justify-center h-full text-red-400 gap-3 text-center">
                                <i className="ri-error-warning-line text-2xl"></i>
                                <span className="px-4">{node.error}</span>
                            </div>
                        ) : (
                            <div className="wiki-content text-zinc-300 text-base" dangerouslySetInnerHTML={{ __html: sanitizedHTML }} />
                        )}
                    </div>
                </div>
            );
        };

        const RecursiveTree = ({ node, isMobile, onClose, onLinkClick }) => {
            const hasChildren = node.children && node.children.length > 0;
            const gapX = isMobile ? 40 : 80;
            const gapY = isMobile ? 20 : 40;

            return (
                <div className="flex items-center" style={{ gap: gapX }}>
                    <WikiCard node={node} isMobile={isMobile} onClose={onClose} onLinkClick={onLinkClick} />
                    {hasChildren && (
                        <div className="flex flex-col relative" style={{ gap: gapY }}>
                            <div className="absolute bg-[#52525b] shadow-[0_0_6px_rgba(59,130,246,0.2)]" style={{ width: '3px', left: `-${gapX}px`, top: 0, bottom: 0, display: node.children.length === 1 ? 'none' : 'block' }} />
                            {node.children.length > 1 && (
                                <>
                                    <div className="absolute bg-[#050508] z-0" style={{ width: '5px', left: `-${gapX}px`, top: '-50px', bottom: '50%' }} />
                                    <div className="absolute bg-[#050508] z-0" style={{ width: '5px', left: `-${gapX}px`, top: '50%', bottom: '-50px' }} />
                                </>
                            )}
                            {node.children.map((childNode) => (
                                <div key={childNode.id} className="relative flex items-center">
                                    <div className="absolute h-[3px] bg-gradient-to-r from-[#52525b] to-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.3)]" style={{ width: `${gapX}px`, left: `-${gapX}px`, top: '50%', transform: 'translateY(-50%)' }} />
                                    <RecursiveTree node={childNode} isMobile={isMobile} onClose={onClose} onLinkClick={onLinkClick} />
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const viewportRef = useRef(null);
            const worldRef = useRef(null);
            const searchInputRef = useRef(null);
            const transformState = useRef({ x: 0, y: 0, scale: 1 });
            const isDragging = useRef(false);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const touchStartDist = useRef(0);
            const touchStartScale = useRef(1);
            const lastDragTime = useRef(0);
            const velocity = useRef({ x: 0, y: 0 });
            const rafId = useRef(null);

            const [tree, setTree] = useState(null);
            const [isMobile, setIsMobile] = useState(false);
            const [searchQuery, setSearchQuery] = useState('');
            const [suggestions, setSuggestions] = useState([]);
            const [isSearching, setIsSearching] = useState(false);
            const [showSuggestions, setShowSuggestions] = useState(false);
            const [zoomLevelDisplay, setZoomLevelDisplay] = useState(1);

            useEffect(() => {
                createRootNode("Internet");
                const handleResize = () => setIsMobile(window.innerWidth <= 768);
                handleResize();
                window.addEventListener('resize', handleResize);
                centerView();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const updateTransform = useCallback(() => {
                if (!worldRef.current) return;
                const { x, y, scale } = transformState.current;
                const rx = Math.round(x);
                const ry = Math.round(y);
                worldRef.current.style.transform = `translate3d(${rx}px, ${ry}px, 0) scale(${scale})`;
                setZoomLevelDisplay(scale);
            }, []);

            const createRootNode = async (title) => {
                const newNode = { id: uuid.v4(), title, content: null, loading: true, error: null, children: [] };
                setTree(newNode);
                fetchNodeContent(newNode.id, title);
            };

            const fetchNodeContent = async (nodeId, title) => {
                try {
                    const data = await fetchWikiPage(title);
                    updateNodeInTree(nodeId, (node) => ({ ...node, title: data.title, content: data.html, loading: false }));
                } catch (err) {
                    updateNodeInTree(nodeId, (node) => ({ ...node, loading: false, error: err.message || 'Failed to load' }));
                }
            };

            const updateNodeInTree = (targetId, updateFn) => {
                setTree((prevTree) => {
                    if (!prevTree) return null;
                    const traverse = (node) => {
                        if (node.id === targetId) return updateFn(node);
                        return { ...node, children: node.children.map(traverse) };
                    };
                    return traverse(prevTree);
                });
            };

            const handleAddChild = (title, parentId) => {
                const newNode = { id: uuid.v4(), title, content: null, loading: true, error: null, children: [], parentId };
                updateNodeInTree(parentId, (node) => ({ ...node, children: [...node.children, newNode] }));
                fetchNodeContent(newNode.id, title);
            };

            const handleRemoveNode = (id) => {
                setTree((prevTree) => {
                    if (!prevTree) return null;
                    if (prevTree.id === id) return null;
                    const traverse = (node) => ({ ...node, children: node.children.filter(c => c.id !== id).map(traverse) });
                    return traverse(prevTree);
                });
            };

            const centerView = () => {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const cardWidth = window.innerWidth <= 768 ? 340 : 450;
                const startX = (vw / 2) - (cardWidth / 2);
                const startY = (vh / 2) - 300;
                gsap.to(transformState.current, { x: startX, y: startY, scale: 1, duration: 0.8, ease: 'power2.inOut', onUpdate: updateTransform });
            };

            const handleZoom = (delta) => {
                const { scale, x, y } = transformState.current;
                const newScale = Math.min(Math.max(0.2, scale + delta), 3);
                const rect = viewportRef.current?.getBoundingClientRect();
                if (!rect) return;
                const cx = rect.width / 2;
                const cy = rect.height / 2;
                const wx = (cx - x) / scale;
                const wy = (cy - y) / scale;
                const newX = cx - (wx * newScale);
                const newY = cy - (wy * newScale);
                gsap.to(transformState.current, { scale: newScale, x: newX, y: newY, duration: 0.3, ease: 'power2.out', onUpdate: updateTransform });
            };

            // Keyboard Shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    gsap.killTweensOf(transformState.current);
                    const PAN_AMOUNT = e.shiftKey ? 200 : 100;
                    let newX = transformState.current.x;
                    let newY = transformState.current.y;
                    let shouldAnimate = false;
                    switch (e.key) {
                        case 'ArrowUp': newY += PAN_AMOUNT; shouldAnimate = true; break;
                        case 'ArrowDown': newY -= PAN_AMOUNT; shouldAnimate = true; break;
                        case 'ArrowLeft': newX += PAN_AMOUNT; shouldAnimate = true; break;
                        case 'ArrowRight': newX -= PAN_AMOUNT; shouldAnimate = true; break;
                        case '=': case '+': if (e.ctrlKey || e.metaKey) { e.preventDefault(); handleZoom(0.2); } break;
                        case '-': if (e.ctrlKey || e.metaKey) { e.preventDefault(); handleZoom(-0.2); } break;
                        case '0': if (e.ctrlKey || e.metaKey) { e.preventDefault(); centerView(); } break;
                    }
                    if (shouldAnimate) gsap.to(transformState.current, { x: newX, y: newY, duration: 0.2, ease: 'power2.out', onUpdate: updateTransform });
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [updateTransform]);

            // Mouse & Touch Interaction
            const handleMouseDown = (e) => {
                if (e.target.closest('.card-body') || e.target.closest('input') || e.target.closest('button')) return;
                isDragging.current = true;
                lastMousePos.current = { x: e.clientX, y: e.clientY };
                velocity.current = { x: 0, y: 0 };
                lastDragTime.current = Date.now();
                if (rafId.current) cancelAnimationFrame(rafId.current);
                gsap.killTweensOf(transformState.current);
                if (viewportRef.current) viewportRef.current.style.cursor = 'grabbing';
            };

            const handleMouseMove = (e) => {
                if (!isDragging.current) return;
                e.preventDefault();
                const dx = e.clientX - lastMousePos.current.x;
                const dy = e.clientY - lastMousePos.current.y;
                const dt = Date.now() - lastDragTime.current;
                transformState.current.x += dx;
                transformState.current.y += dy;
                updateTransform();
                if (dt > 0) velocity.current = { x: dx / dt, y: dy / dt };
                lastMousePos.current = { x: e.clientX, y: e.clientY };
                lastDragTime.current = Date.now();
            };

            const handleMouseUp = () => {
                if (!isDragging.current) return;
                isDragging.current = false;
                if (viewportRef.current) viewportRef.current.style.cursor = 'grab';
                const { x, y } = velocity.current;
                const magnitude = Math.sqrt(x * x + y * y);
                if (magnitude > 0.1) {
                    gsap.to(transformState.current, {
                        x: transformState.current.x + x * 300,
                        y: transformState.current.y + y * 300,
                        duration: 0.8,
                        ease: 'power2.out',
                        onUpdate: updateTransform
                    });
                }
            };

            const handleWheel = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    handleZoom(-e.deltaY * 0.002);
                } else {
                    if (e.target.closest('.card-body')) return;
                    transformState.current.x -= e.deltaX;
                    transformState.current.y -= e.deltaY;
                    updateTransform();
                }
            };

            useEffect(() => {
                const el = viewportRef.current;
                if (!el) return;
                const onTouchStart = (e) => {
                     if (e.target.closest('.card-body') || e.target.closest('input') || e.target.closest('button')) return;
                     if (e.touches.length === 2 || !e.target.closest('.card-body')) e.preventDefault();
                     isDragging.current = true;
                     if (e.touches.length === 1) {
                         lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                         velocity.current = { x: 0, y: 0 };
                         lastDragTime.current = Date.now();
                         gsap.killTweensOf(transformState.current);
                     } else if (e.touches.length === 2) {
                         const dx = e.touches[0].clientX - e.touches[1].clientX;
                         const dy = e.touches[0].clientY - e.touches[1].clientY;
                         touchStartDist.current = Math.hypot(dx, dy);
                         touchStartScale.current = transformState.current.scale;
                     }
                };
                const onTouchMove = (e) => {
                    if (!isDragging.current) return;
                    if (e.touches.length === 2 || !e.target.closest('.card-body')) e.preventDefault();
                    if (e.touches.length === 1) {
                        const clientX = e.touches[0].clientX;
                        const clientY = e.touches[0].clientY;
                        const dx = clientX - lastMousePos.current.x;
                        const dy = clientY - lastMousePos.current.y;
                        const dt = Date.now() - lastDragTime.current;
                        transformState.current.x += dx;
                        transformState.current.y += dy;
                        updateTransform();
                        if (dt > 0) velocity.current = { x: dx / dt, y: dy / dt };
                        lastMousePos.current = { x: clientX, y: clientY };
                        lastDragTime.current = Date.now();
                    } else if (e.touches.length === 2) {
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const dist = Math.hypot(dx, dy);
                        if (touchStartDist.current > 0) {
                            const newScale = touchStartScale.current * (dist / touchStartDist.current);
                            transformState.current.scale = Math.min(Math.max(0.2, newScale), 3);
                            updateTransform();
                        }
                    }
                };
                const onTouchEnd = (e) => { if (e.touches.length === 0) { isDragging.current = false; handleMouseUp(); } };
                el.addEventListener('touchstart', onTouchStart, { passive: false });
                el.addEventListener('touchmove', onTouchMove, { passive: false });
                el.addEventListener('touchend', onTouchEnd);
                return () => {
                    el.removeEventListener('touchstart', onTouchStart);
                    el.removeEventListener('touchmove', onTouchMove);
                    el.removeEventListener('touchend', onTouchEnd);
                };
            }, [updateTransform]);

            // Search
            useEffect(() => {
                const delayDebounce = setTimeout(async () => {
                    if (searchQuery.length > 1) {
                        setIsSearching(true);
                        try {
                            const results = await fetchSuggestions(searchQuery);
                            setSuggestions(results);
                            setShowSuggestions(true);
                        } catch (e) { console.error(e); } finally { setIsSearching(false); }
                    } else {
                        setSuggestions([]);
                        setShowSuggestions(false);
                    }
                }, 300);
                return () => clearTimeout(delayDebounce);
            }, [searchQuery]);

            const selectSuggestion = (title) => {
                createRootNode(title);
                setSearchQuery('');
                setShowSuggestions(false);
                centerView();
            };

            return (
                <div className="w-full h-screen bg-[#050508] relative overflow-hidden text-slate-200 font-sans selection:bg-blue-500/30">
                    {/* Search Bar */}
                    <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 w-[90%] max-w-[420px]">
                        <div className="relative group">
                            <div className={`absolute inset-0 bg-blue-500/20 rounded-xl blur-lg transition-opacity duration-300 ${showSuggestions ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'}`}></div>
                            <div className="relative bg-[#18181b]/90 backdrop-blur-xl border border-[#27272a] rounded-xl flex items-center px-4 py-3 shadow-2xl transition-colors focus-within:border-blue-500/50">
                                <i className="ri-search-line text-slate-400 mr-3 text-lg"></i>
                                <input ref={searchInputRef} type="text" className="bg-transparent border-none outline-none text-white placeholder-slate-500 flex-1 text-base" placeholder="Search Wikipedia..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} onFocus={() => { if(suggestions.length) setShowSuggestions(true); }} />
                                {isSearching && <div className="w-4 h-4 border-2 border-slate-600 border-t-blue-500 rounded-full animate-spin"></div>}
                            </div>
                        </div>
                        {showSuggestions && suggestions.length > 0 && (
                            <div className="absolute top-full left-0 right-0 mt-2 bg-[#18181b] border border-[#27272a] rounded-xl shadow-2xl overflow-hidden z-50">
                                {suggestions.map((s, i) => (
                                    <div key={i} className="px-4 py-3 hover:bg-[#27272a] cursor-pointer flex justify-between items-center group transition-colors" onClick={() => selectSuggestion(s.title)}>
                                        <span className="font-medium text-slate-200 group-hover:text-white">{s.title}</span>
                                        <span className="text-xs text-slate-500 truncate max-w-[40%]">{s.description}</span>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                    {/* Controls */}
                    <div className="fixed bottom-6 right-6 z-40 flex flex-col gap-3">
                        <button onClick={() => handleZoom(0.2)} className="w-12 h-12 bg-[#18181b]/90 backdrop-blur-md border border-[#27272a] rounded-xl text-slate-400 hover:text-white hover:border-blue-500/50 hover:shadow-[0_0_15px_rgba(59,130,246,0.3)] transition-all flex items-center justify-center text-xl shadow-lg" title="Zoom In"><i className="ri-add-line"></i></button>
                        <div className="bg-[#18181b]/90 backdrop-blur-md border border-[#27272a] rounded-xl px-2 py-1 text-center min-w-[3rem]"><span className="text-xs font-mono text-blue-400">{zoomLevelDisplay.toFixed(1)}x</span></div>
                        <button onClick={() => handleZoom(-0.2)} className="w-12 h-12 bg-[#18181b]/90 backdrop-blur-md border border-[#27272a] rounded-xl text-slate-400 hover:text-white hover:border-blue-500/50 hover:shadow-[0_0_15px_rgba(59,130,246,0.3)] transition-all flex items-center justify-center text-xl shadow-lg" title="Zoom Out"><i className="ri-subtract-line"></i></button>
                        <button onClick={centerView} className="w-12 h-12 bg-[#18181b]/90 backdrop-blur-md border border-[#27272a] rounded-xl text-slate-400 hover:text-white hover:border-blue-500/50 hover:shadow-[0_0_15px_rgba(59,130,246,0.3)] transition-all flex items-center justify-center text-xl shadow-lg mt-2" title="Reset View"><i className="ri-focus-3-line"></i></button>
                    </div>
                    {/* Viewport */}
                    <div id="viewport" ref={viewportRef} className="w-full h-full cursor-grab active:cursor-grabbing touch-none" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onWheel={handleWheel}>
                        <div id="world" ref={worldRef} className="absolute origin-top-left will-change-transform" style={{ transform: 'translate3d(0px, 0px, 0px) scale(1)' }}>
                            {tree && <RecursiveTree node={tree} isMobile={isMobile} onClose={handleRemoveNode} onLinkClick={handleAddChild} />}
                        </div>
                    </div>
                    {!tree && !isSearching && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <div className="text-center opacity-30">
                                <i className="ri-share-line text-6xl mb-4 block"></i>
                                <p className="text-xl font-light tracking-wide">Enter a topic to begin exploration</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
